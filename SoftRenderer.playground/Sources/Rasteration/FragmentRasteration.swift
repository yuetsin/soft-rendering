import Cocoa

public func rasterize<F: FloatingPoint>(
  canvasWidth: F, canvasHeight: F, pA tPointA: Vector3D<F>, pB tPointB: Vector3D<F>,
  pC tPointC: Vector3D<F>,
  handler: (RenderPoint, FragmentInterpolate<Double>) -> Void
) {
  let z0: Double = tPointA.z as! Double
  let z1: Double = tPointB.z as! Double
  let z2: Double = tPointC.z as! Double
  let flatPointA = Vector2D<F>(tPointA.x, tPointA.y)
  let flatPointB = Vector2D<F>(tPointB.x, tPointB.y)
  let flatPointC = Vector2D<F>(tPointC.x, tPointC.y)

  rasterize(
    canvasWidth: canvasWidth, canvasHeight: canvasHeight, pA: flatPointA, pB: flatPointB,
    pC: flatPointC,
    handler: { point, interp in
      // use ugly expression to avoid
      // "The compiler is unable to type-check this expression in reasonable time" error
      var zoo = (1 / z0) * interp.u
      zoo += (1 / z1) * interp.v
      zoo += (1 / z2) * interp.w

      handler(RenderPoint(point.x, point.y, 1 / zoo), interp)
    })
}

public func barycentric<F: FloatingPoint>(points: [Vector2D<F>], checkPoint: Vector2D<F>)
  -> Vector3D<F>
{
  let left = Vector3D<F>(
    points[2].x - points[0].x, points[1].x - points[0].x, points[0].x - checkPoint.x)
  let right = Vector3D<F>(
    points[2].y - points[0].y, points[1].y - points[0].y, points[0].y - checkPoint.y)
  let result = left.cross(with: right)
  if abs(result.z) < 1 {
    return Vector3D<F>(-1, 1, 1)
  }
  return Vector3D<F>(1 - (result.x + result.y) / result.z, result.y / result.z, result.x / result.z)
}

public func rasterize<F: FloatingPoint>(
  canvasWidth: F, canvasHeight: F, pA P1: Vector2D<F>, pB P2: Vector2D<F>, pC P3: Vector2D<F>,
  handler: (Vector2i, FragmentInterpolate<Double>) -> Void
) {

  let width = Int(canvasWidth as! Double)
  let height = Int(canvasHeight as! Double)
  var bboxMinX = width
  var bboxMinY = height
  var bboxMaxX = 0
  var bboxMaxY = 0

  let points = [P1, P2, P3]
  for point in points {
    let px = Int(point.x as! Double)
    let py = Int(point.y as! Double)
    bboxMinX = min(bboxMinX, px)
    bboxMaxX = max(bboxMaxX, px)
    bboxMinY = min(bboxMinY, py)
    bboxMaxY = max(bboxMaxY, py)
  }

  if bboxMinX > width || bboxMaxX < 0 || bboxMinY > height || bboxMaxY < 0 {
    // out of screen
    return
  }

  for px in max(bboxMinX, 0)...min(bboxMaxX, width) {
    for py in max(bboxMinY, 0)...min(bboxMaxY, height) {
      let keypoint = barycentric(
        points: points, checkPoint: Vector2D<F>(Double(px) as! F, Double(py) as! F))
      if keypoint.x < 0 || keypoint.y < 0 || keypoint.z < 0 {
        continue
      }
      let result = Vector2i(px, py)

      let P1x = P1.x as! Double
      let P1y = P1.y as! Double
      let P2x = P2.x as! Double
      let P2y = P2.y as! Double
      let P3x = P3.x as! Double
      let P3y = P3.y as! Double

      let doubleX = Double(px)
      let doubleY = Double(py)

      // expression generated by Mathematica
      let v =
        -(((doubleY - P1y) * (P1x - P3x) - (doubleX - P1x) * (P1y - P3y))
        / ((P1y - P2y) * (P1x - P3x) - (P1x - P2x) * (P1y - P3y)))

      let w =
        -((-doubleY * P1x + doubleX * P1y + doubleY * P2x - P1y * P2x - doubleX * P2y + P1x * P2y)
        / (P1y * P2x - P1x * P2y - P1y * P3x + P2y * P3x + P1x * P3y - P2x * P3y))

      let u = 1 - v - w

      handler(result, FragmentInterpolate<Double>(u: u, v: v, w: w))
    }
  }
}
