import Cocoa

public func rasterize<F: FloatingPoint>(canvasWidth: F, canvasHeight: F, pA tPointA: Vector3D<F>, pB tPointB: Vector3D<F>, pC tPointC: Vector3D<F>,
                                        handler: (RenderPoint, FragmentInterpolate<Double>) -> Void) {
    let z0 = tPointA.z as! Double, z1: Double = tPointB.z as! Double, z2: Double = tPointC.z as! Double
    let flatPointA = Vector2D<F>(tPointA.x, tPointA.y)
    let flatPointB = Vector2D<F>(tPointB.x, tPointB.y)
    let flatPointC = Vector2D<F>(tPointC.x, tPointC.y)
    rasterize(canvasWidth: canvasWidth, canvasHeight: canvasHeight, pA: flatPointA, pB: flatPointB, pC: flatPointC, handler: { point, interp in
        // use ugly expression to avoid
        // "The compiler is unable to type-check this expression in reasonable time" error
        var z: Double = z0 * interp.u
        z += z1 * interp.v
        z += z2 * interp.w
        handler(RenderPoint(point.x, point.y, z), interp)
    })
}
//
//public func rasterize<F: FloatingPoint>(canvasWidth: F, canvasHeight: F, pA tPointA: Vector2D<F>, pB tPointB: Vector2D<F>, pC tPointC: Vector2D<F>,
//                                        handler: (Vector2i, FragmentInterpolate<Double>) -> Void) {
//    var P1 = tPointA, P2 = tPointB, P3 = tPointC
//
//    var inverse12 = false
//    var inverse13 = false
//    var inverse23 = false
//
//    if P1.y > P2.y {
//        (P1, P2) = (P2, P1)
//        inverse12 = !inverse12
//    }
//    if P1.y > P3.y {
//        (P1, P3) = (P3, P1)
//        inverse13 = !inverse13
//    }
//    if P2.y > P3.y {
//        (P2, P3) = (P3, P2)
//        inverse23 = !inverse23
//    }
//
//    let total_height = Int((P3.y - P1.y) as! Double)
//    for i in 0 ..< total_height {
//        var A, B: Vector2D<F>!
//        var segment_height, alpha, beta: Double!
//        var offset: Int!
//
//        let second_half = Double(i) > (P2.y - P1.y) as! Double || (P2.y == P1.y)
//
//        if second_half {
//            segment_height = (P3.y - P2.y) as? Double
//            offset = Int((P2.y - P1.y) as! Double)
//        } else {
//            segment_height = (P2.y - P1.y) as? Double
//            offset = 0
//        }
//        alpha = Double(i) / Double(total_height)
//        beta = Double(i - offset) / segment_height
//        A = P1 + (P3 - P1) * (alpha as! F)
//
//        if second_half {
//            B = P2 + (P3 - P2) * (beta as! F)
//
//        } else {
//            B = P1 + (P2 - P1) * (beta as! F)
//        }
//
//        let lowerBound = min(A.x, B.x) as! Double
//        let upperBound = max(A.x, B.x) as! Double
//
//        for j in Int(lowerBound) ... Int(upperBound) {
//            let x = j, y = Int(P1.y as! Double) + i
//
//            let doubleX = Double(x), doubleY = Double(y)
//
//            let P1x = P1.x as! Double, P1y = P1.y as! Double
//            let P2x = P2.x as! Double, P2y = P2.y as! Double
//            let P3x = P3.x as! Double, P3y = P3.y as! Double
//
//            // expression generated by Mathematica
//            var v = -(((doubleY - P1y) * (P1x - P3x) - (doubleX - P1x) * (P1y -
//                    P3y)) / ((P1y - P2y) * (P1x - P3x) - (P1x - P2x) * (P1y -
//                        P3y)))
//
//            var w = -((-doubleY * P1x + doubleX * P1y + doubleY * P2x - P1y * P2x - doubleX * P2y +
//                    P1x * P2y) / (
//                    P1y * P2x - P1x * P2y - P1y * P3x + P2y * P3x + P1x * P3y -
//                        P2x * P3y))
//
//            var u = 1 - v - w
//
//            if inverse12 {
//                (u, v) = (v, u)
//            }
//            if inverse13 {
//                (u, w) = (w, u)
//            }
//            if inverse23 {
//                (v, w) = (w, v)
//            }
//
//            handler(Vector2i(x, y), FragmentInterpolate<Double>(u: u, v: v, w: w))
//        }
//    }
//}

public func barycentric<F: FloatingPoint>(points: [Vector2D<F>], checkPoint: Vector2D<F>) -> Vector3D<F> {
    let left = Vector3D<F>(points[2].x - points[0].x, points[1].x - points[0].x, points[0].x - checkPoint.x)
    let right = Vector3D<F>(points[2].y - points[0].y, points[1].y - points[0].y, points[0].y - checkPoint.y)
    let result = left.crossMultiply(with: right)
    if abs(result.z) < 1 {
        return Vector3D<F>(-1, 1, 1)
    }
    return Vector3D<F>(1 - (result.x + result.y) / result.z, result.y / result.z, result.x / result.z)
}


public func rasterize<F: FloatingPoint>(canvasWidth: F, canvasHeight: F, pA P1: Vector2D<F>, pB P2: Vector2D<F>, pC P3: Vector2D<F>, handler: (Vector2i, FragmentInterpolate<Double>) -> Void) {
    
    let width = Int(canvasWidth as! Double), height = Int(canvasHeight as! Double)
    var bboxMinX = width, bboxMinY = height
    var bboxMaxX = 0, bboxMaxY = 0
    
    let points = [P1, P2, P3]
    for point in points {
        let px = Int(point.x as! Double), py = Int(point.y as! Double)
        bboxMinX = min(bboxMinX, px)
        bboxMaxX = max(bboxMaxX, px)
        bboxMinY = min(bboxMinY, py)
        bboxMaxY = max(bboxMaxY, py)
    }
    
    if bboxMinX > width || bboxMaxX < 0 || bboxMinY > height || bboxMaxY < 0 {
        // out of screen
        return
    }
    
    for px in max(bboxMinX, 0) ... min(bboxMaxX, width) {
        for py in max(bboxMinY, 0) ... min(bboxMaxY, height) {
            let keypoint = barycentric(points: points, checkPoint: Vector2D<F>(Double(px) as! F, Double(py) as! F))
            if keypoint.x < 0 || keypoint.y < 0 || keypoint.z < 0 {
                continue
            }
            let result = Vector2i(px, py)
            
            let P1x = P1.x as! Double, P1y = P1.y as! Double
            let P2x = P2.x as! Double, P2y = P2.y as! Double
            let P3x = P3.x as! Double, P3y = P3.y as! Double
            
            let doubleX = Double(px), doubleY = Double(py)

            // expression generated by Mathematica
            let v = -(((doubleY - P1y) * (P1x - P3x) - (doubleX - P1x) * (P1y -
                    P3y)) / ((P1y - P2y) * (P1x - P3x) - (P1x - P2x) * (P1y -
                        P3y)))

            let w = -((-doubleY * P1x + doubleX * P1y + doubleY * P2x - P1y * P2x - doubleX * P2y +
                    P1x * P2y) / (
                    P1y * P2x - P1x * P2y - P1y * P3x + P2y * P3x + P1x * P3y -
                        P2x * P3y))

            let u = 1 - v - w
            
            handler(result, FragmentInterpolate<Double>(u: u, v: v, w: w))
        }
    }
}
