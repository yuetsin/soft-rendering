import Cocoa

public func rasterize<F: FloatingPoint>(pA tPointA: Point3D<F>, pB tPointB: Point3D<F>, pC tPointC: Point3D<F>,
                                        handler: (Point3i, FragmentInterpolate<Double>) -> Void) {
    let z0 = tPointA.z as! Double, z1: Double = tPointB.z as! Double, z2: Double = tPointC.z as! Double
    let flatPointA = Point2D<F>(tPointA.x, tPointA.y)
    let flatPointB = Point2D<F>(tPointB.x, tPointB.y)
    let flatPointC = Point2D<F>(tPointC.x, tPointC.y)
    rasterize(pA: flatPointA, pB: flatPointB, pC: flatPointC, handler: { point, interp in
        // use ugly expression to avoid
        // "The compiler is unable to type-check this expression in reasonable time" error
        var z: Double = z0 * interp.u
        z += z1 * interp.v
        z += z2 * interp.w
        handler(Point3i(point.x, point.y, z), interp)
    })
}

public func rasterize<F: FloatingPoint>(pA tPointA: Point2D<F>, pB tPointB: Point2D<F>, pC tPoint3: Point2D<F>,
                                        handler: (Point2i, FragmentInterpolate<Double>) -> Void) {
    var P1 = tPointA, P2 = tPointB, P3 = tPoint3
    
    var inverse12 = false
    var inverse13 = false
    var inverse23 = false
    
    if P1.y > P2.y {
        (P1, P2) = (P2, P1)
        inverse12 = true
    }
    if P1.y > P3.y {
        (P1, P3) = (P3, P1)
        inverse13 = true
    }
    if P2.y > P3.y {
        (P2, P3) = (P3, P2)
        inverse23 = true
    }
    let total_height = Int((P3.y - P1.y) as! Double)
    for i in 0 ..< total_height {
        var A, B: Point2D<F>!
        var segment_height, alpha, beta: Double!
        var offset: Int!

        let second_half = Double(i) > (P2.y - P1.y) as! Double || (P2.y == P1.y)

        if second_half {
            segment_height = (P3.y - P2.y) as? Double
            offset = Int((P2.y - P1.y) as! Double)
        } else {
            segment_height = (P2.y - P1.y) as? Double
            offset = 0
        }
        alpha = Double(i) / Double(total_height)
        beta = Double(i - offset) / segment_height
        A = P1 + (P3 - P1) * (alpha as! F)

        if second_half {
            B = P2 + (P3 - P2) * (beta as! F)
        } else {
            B = P1 + (P2 - P1) * (beta as! F)
        }
        if A.x > B.x {
            (A, B) = (B, A)
        }

        for j in Int(A.x as! Double) ... Int(B.x as! Double) {
            let x = j, y = Int(P1.y as! Double) + i
            
            let doubleX = Double(x), doubleY = Double(y)
            
            let P1x = P1.x as! Double, P1y = P1.y as! Double
            let P2x = P2.x as! Double, P2y = P2.y as! Double
            let P3x = P3.x as! Double, P3y = P3.y as! Double
            
            // expression generated by Mathematica
            var v = -(((doubleY - P1y) * (P1x - P3x) - (doubleX - P1x) * (P1y -
                    P3y)) / ((P1y - P2y) * (P1x - P3x) - (P1x - P2x) * (P1y -
                        P3y)))

            var w = -((-doubleY * P1x + doubleX * P1y + doubleY * P2x - P1y * P2x - doubleX * P2y +
                    P1x * P2y) / (
                    P1y * P2x - P1x * P2y - P1y * P3x + P2y * P3x + P1x * P3y -
                        P2x * P3y))

            var u = 1 - v - w
            
            if inverse12 {
                (u, v) = (v, u)
            }
            if inverse13 {
                (u, w) = (w, u)
            }
            if inverse23 {
                (v, w) = (w, v)
            }

            handler(Point2i(x, y), FragmentInterpolate<Double>(u: u, v: v, w: w))
        }
    }
}
