import Cocoa

@inlinable
public func ColorInterpolate(since: CIColor, till: CIColor, progress: CGFloat) -> CIColor {

    let redDiff = till.red - since.red
    let greenDiff = till.green - since.green
    let blueDiff = till.blue - since.blue
    let alphaDiff = till.alpha - since.alpha

    // due to precision issues, calculating result might exceed 0 or 1.
    // normalize it to avoid critical errors.
    return CIColor(red: min(1, max(0, since.red + progress * redDiff)),
                   green: min(1, max(0, since.green + progress * greenDiff)),
                   blue: min(1, max(0, since.blue + progress * blueDiff)),
                   alpha: min(1, max(0, since.alpha + progress * alphaDiff)))
}

@inlinable
public func GouraudInterpolate(at P: Point2d,
                               pointA P1: Point2d, pointB P2: Point2d, pointC P3: Point2d,
                               colorA: CIColor, colorB: CIColor, colorC: CIColor) -> CIColor {
    // expression generated by Mathematica
    let u = CGFloat(-(((P.y - P1.y) * (P1.x - P3.x) - (P.x - P1.x) * (P1.y -
            P3.y)) / ((P1.y - P2.y) * (P1.x - P3.x) - (P1.x - P2.x) * (P1.y -
                P3.y))))

    let v = CGFloat(-((-P.y * P1.x + P.x * P1.y + P.y * P2.x - P1.y * P2.x - P.x * P2.y +
            P1.x * P2.y) / (
            P1.y * P2.x - P1.x * P2.y - P1.y * P3.x + P2.y * P3.x + P1.x * P3.y -
                P2.x * P3.y)))

    let t = 1 - u - v


    // due to precision issues, calculating result might exceed 0 or 1.
    // normalize it to avoid critical errors.
    let red = min(1, max(0, colorA.red * t + colorB.red * u + colorC.red * v))
    let green = min(1, max(0, colorA.green * t + colorB.green * u + colorC.green * v))
    let blue = min(1, max(0, colorA.blue * t + colorB.blue * u + colorC.blue * v))
    let alpha = min(1, max(0, colorA.alpha * t + colorB.alpha * u + colorC.alpha * v))

    return CIColor(red: red, green: green, blue: blue, alpha: alpha)
}
