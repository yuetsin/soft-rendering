import Foundation

public func perspectiveCorrection(P: Vector3d, P1: Vector3d, P2: Vector3d, P3: Vector3d) -> FragmentInterpolate<Double> {
    // expression generated by Mathematica
    let u = -((-P.z * P2.y * P3.x + P.y * P2.z * P3.x + P.z * P2.x * P3.y - P.x * P2.z * P3.y - P.y * P2.x * P3.z + P.x * P2.y * P3.z)/(P1.z * P2.y * P3.x - P1.y * P2.z * P3.x - P1.z * P2.x * P3.y + P1.x * P2.z * P3.y + P1.y * P2.x * P3.z - P1.x * P2.y * P3.z))
    let v = -((P.z * P1.y * P3.x - P.y * P1.z * P3.x - P.z * P1.x * P3.y + P.x * P1.z * P3.y + P.y * P1.x * P3.z - P.x * P1.y * P3.z)/(P1.z * P2.y * P3.x - P1.y * P2.z * P3.x - P1.z * P2.x * P3.y + P1.x * P2.z * P3.y + P1.y * P2.x * P3.z - P1.x * P2.y * P3.z))
    let w = -((P.z * P1.y * P2.x - P.y * P1.z * P2.x - P.z * P1.x * P2.y + P.x * P1.z * P2.y + P.y * P1.x * P2.z - P.x * P1.y * P2.z)/(-P1.z * P2.y * P3.x + P1.y * P2.z * P3.x + P1.z * P2.x * P3.y - P1.x * P2.z * P3.y - P1.y * P2.x * P3.z + P1.x * P2.y * P3.z))
    
    return FragmentInterpolate(u: u, v: v, w: w)
}
